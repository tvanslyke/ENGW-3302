% This is annote.bib
% Author: Ayman Ammoura
% A demo for CMPUT 603 Fall 2002.
% The order of the following entries is irrelevant. They will be sorted according to the
% bibliography style used.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%https://docs.google.com/document/d/16GVtCpzK8sIHNc2qZz6RN8amICNBtvjWUod2SujZVEo/edit#
@article{Rompf,
	author = {Rompf, Tiark and Sujeeth, Arvind K. and Brown, Kevin J. and Lee, HyoukJoong and Chafi, Hassan and Olukotun, Kunle},
	title = {Surgical Precision JIT Compilers},
	journal = {SIGPLAN Not.},
	issue_date = {June 2014},
	volume = {49},
	number = {6},
	month = jun,
	year = {2014},
	issn = {0362-1340},
	pages = {41--52},
	numpages = {12},
	url = {http://doi.acm.org/10.1145/2666356.2594316},
	doi = {10.1145/2666356.2594316},
	acmid = {2594316},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {JIT compilation, program generation, staging},
	annote = {
		Addresses the problem of unreliability in modern JIT compilers, like the HotSpot Server compiler (JVM).  Proposed is a programmer-visible API to the respective managed language JIT compiler.  Lancet, the corresponding implementation of the proposed JIT compiler, makes use of Abstract Interpretation.
	}
} 

%%
@article{Lifflander,
	author = {Lifflander, Jonathan and Krishnamoorthy, Sriram},
	title = {Cache Locality Optimization for Recursive Programs},
	journal = {SIGPLAN Not.},
	issue_date = {June 2017},
	volume = {52},
	number = {6},
	month = jun,
	year = {2017},
	issn = {0362-1340},
	pages = {1--16},
	numpages = {16},
	url = {http://doi.acm.org/10.1145/3140587.3062385},
	doi = {10.1145/3140587.3062385},
	acmid = {3062385},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {locality optimization, recursive programs},
	annote = {
		Describes a method for optimizing non-trivial recursive function execution with automatic generation of parallel code.  The proposed method involves statically annotating function definitions with desciptions of data access patterns.  With these annotations, recursive function execution is transformed into (user-level) threaded code where each thread handles the execution of function call.  
	}
}

%%
@article{Stock,
	author = {Stock, Kevin and Kong, Martin and Grosser, Tobias and Pouchet, Louis-No\"{e}l and Rastello, Fabrice and Ramanujam, J. and Sadayappan, P.},
	title = {A Framework for Enhancing Data Reuse via Associative Reordering},
	journal = {SIGPLAN Not.},
	issue_date = {June 2014},
	volume = {49},
	number = {6},
	month = jun,
	year = {2014},
	issn = {0362-1340},
	pages = {65--76},
	numpages = {12},
	url = {http://doi.acm.org/10.1145/2666356.2594342},
	doi = {10.1145/2666356.2594342},
	acmid = {2594342},
	publisher = {ACM},
	address = {New York, NY, USA},
	annote = {
		Proposes optimization techniques for stencil operations (loop -> compute -> update) with a focus on minimizing usage of register real estate.  Leverages associativity and commutativity of addition and multiplication to transform operations in nested loop to develop efficient access patterns that use a minimal number of registers.
	}
}

%%
@article{Dissegna,
	author = {Dissegna, Stefano and Logozzo, Francesco and Ranzato, Francesco},
	title = {Tracing Compilation by Abstract Interpretation},
	journal = {SIGPLAN Not.},
	issue_date = {January 2014},
	volume = {49},
	number = {1},
	month = jan,
	year = {2014},
	issn = {0362-1340},
	pages = {47--59},
	numpages = {13},
	url = {http://doi.acm.org/10.1145/2578855.2535866},
	doi = {10.1145/2578855.2535866},
	acmid = {2535866},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {abstract interpretation, trace semantics, tracing compilation},
	annote = {
		Largely theoretical and abstract.  Focuses on optimizing dynamic languages through the usage of a tracing JIT.   
	}
}

%%
@inproceedings{Ainsworth,
	author = {Ainsworth, Sam and Jones, Timothy M.},
	title = {Software Prefetching for Indirect Memory Accesses},
	booktitle = {Proceedings of the 2017 International Symposium on Code Generation and Optimization},
	series = {CGO '17},
	year = {2017},
	isbn = {978-1-5090-4931-8},
	location = {Austin, USA},
	pages = {305--317},
	numpages = {13},
	url = {http://dl.acm.org/citation.cfm?id=3049832.3049865},
	acmid = {3049865},
	publisher = {IEEE Press},
	address = {Piscataway, NJ, USA},
	keywords = {Compiler Analysis, Software Prefetching},
	annote = {
		Proposes method of generating code for software-level cache prefetching in contexts where hardware prefetching is deemed insufficient.  Focuses on reducing memory latency in contects where indirect memory accesses typically yield poor cache efficiency (linked-lists, trees, graphs, etc).  All code generation is done through static analysis at compile-time (no JIT).  Implemented in LLVM - benchmarked agains manually-inserted prefetches and shows comparable performance.  Results are very promising, 2.1x - 2.7x speedups.
	}
} 

%%
@inproceedings{Tran,
	author={K. A. Tran and T. E. Carlson and K. Koukos and M. Sj√§lander and V. Spiliopoulos and S. Kaxiras and A. Jimborean},
	title={Clairvoyance: Look-ahead compile-time scheduling},
	booktitle={2017 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
	year={2017},
	volume={},
	number={},
	pages={171-184},
	keywords={optimisation;program compilers;scheduling;OoO execution engine;clairvoyance;look-ahead compile-time scheduling;out-of-order execution engine;single-threaded execution;standard O3 optimizations;Engines;Hardware;Memory management;Parallel processing;Performance evaluation;Prefetching;Registers},
	doi={10.1109/CGO.2017.7863738},
	ISSN={},
	month={Feb},
	annote = {
		Proposes a method for compile-time reordering of memory-bound instructions to improve performance on non-complex out-of-order CPUs.  Method consists of splitting instruction sequences in loop bodies into multiple "Access Phases" and "Execute Phases".  Memory-bound instructions are hoisted up into access phases in a safe, dependency-aware manner while following execute phases are simplified to reduce register pressure.  Benchmark results show mostly small improvements across different C library recompilations, with a few large improvements and occasional pessimisation.
	}
}

%%
@inproceedings{Paisante,
	author = {Paisante, Vitor and Maalej, Maroua and Barbosa, Leonardo and Gonnord, Laure and Quint\~{a}o Pereira, Fernando Magno},
	title = {Symbolic Range Analysis of Pointers},
	booktitle = {Proceedings of the 2016 International Symposium on Code Generation and Optimization},
	series = {CGO '16},
	year = {2016},
	isbn = {978-1-4503-3778-6},
	location = {Barcelona, Spain},
	pages = {171--181},
	numpages = {11},
	url = {http://doi.acm.org/10.1145/2854038.2854050},
	doi = {10.1145/2854038.2854050},
	acmid = {2854050},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {Alias analysis, precision, range analysis, speed},
	annote = {
		Proposes a method which employs abstract interpretation to conduct global and local alias analysis on pointers.  Particularly, the method focuses on deducing whether a subsection of a given pointed-to range aliases a subsection of another.  Using symbolic methods, while-program alias analysis can be conducted in linear time.
	}
}

%% 
@article{Ko,
	author = {Ko, Yousun and Burgstaller, Bernd and Scholz, Bernhard},
	title = {LaminarIR: Compile-time Queues for Structured Streams},
	journal = {SIGPLAN Not.},
	issue_date = {June 2015},
	volume = {50},
	number = {6},
	month = jun,
	year = {2015},
	issn = {0362-1340},
	pages = {121--130},
	numpages = {10},
	url = {http://doi.acm.org/10.1145/2813885.2737994},
	doi = {10.1145/2813885.2737994},
	acmid = {2737994},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {compiler optimization, performance analysis, program transformation, stream programming, synchronous data flow},
	annote = {
		
	}
} 

%%
@article{Mehta,
	author = {Mehta, Sanyam and Yew, Pen-Chung},
	title = {Improving Compiler Scalability: Optimizing Large Programs at Small Price},
	journal = {SIGPLAN Not.},
	issue_date = {June 2015},
	volume = {50},
	number = {6},
	month = jun,
	year = {2015},
	issn = {0362-1340},
	pages = {143--152},
	numpages = {10},
	url = {http://doi.acm.org/10.1145/2813885.2737954},
	doi = {10.1145/2813885.2737954},
	acmid = {2737954},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {Compiler scalability, O-molecule, optimization, polyhedral model, statement condensation},
	annote = {
		Proposes alternative to typical compiler dependency model; blocks of statements, rather than individual statements themselves, are viewed in aggregate and modelled as single nodes in a dependency graph.  This 
	}
}

@unpublished{Carruth,
	title= {Efficiency with Algorithms, Performance with Data Structures},
	author = {Chandler Carruth},
	year = {2014},
	note= {~CppCon 2014
	},
	URL= {https://cppcon2014.sched.com/event/1lYBpr1?iframe=no},
}

@inproceedings{Pluto,
  title={A Practical and Fully Automatic Polyhedral Program Optimization System},
  author={Uday Bondhugula and J. Ramanujam and P. Sadayappan},
  year={2007}
}



%%
